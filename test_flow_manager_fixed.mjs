import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Simular las dependencias necesarias
const MockMessageService = {
    sendMainMenu: async (phoneNumber) => {
        console.log(`üì± Enviando men√∫ principal a ${phoneNumber}`);
    },
    sendTextMessage: async (phoneNumber, message) => {
        console.log(`üì± Enviando mensaje a ${phoneNumber}: ${message}`);
    }
};

// Simular extractMenuCommand
function extractMenuCommand(message) {
    if (!message) return '';

    const normalizedMessage = message.toLowerCase().trim();

    const menuPatterns = {
        'ping': 'ping',
        'test de conexi√≥n': 'ping',
        'test de conexion': 'ping',
        'verificar estado': 'ping',
        'conexi√≥n': 'ping',
        'conexion': 'ping',
        'verificar estado de tu conexi√≥n': 'ping',
        'üì° test de conexi√≥n': 'ping',
        'üì° test de conexion': 'ping',

        'ticket': 'ticket',
        'soporte t√©cnico': 'ticket',
        'soporte tecnico': 'ticket',
        'reportar problemas': 'ticket',
        'crear ticket': 'ticket',
        'reportar problema': 'ticket',
        'reportar falla': 'ticket',
        'reportar problemas t√©cnicos': 'ticket',
        'reportar problemas tecnico': 'ticket',
        'soporte': 'ticket',
        'ya soy cliente': 'soporte',
        'üîß soporte t√©cnico': 'ticket',
        'üîß soporte tecnico': 'ticket',

        'factura': 'factura',
        'mi factura': 'factura',
        'facturas': 'factura',
        'consultar factura': 'factura',
        'consultar y descargar facturas': 'factura',

        'mejorar_plan': 'mejorar_plan',
        'mejorar plan': 'mejorar_plan',
        'upgrade de velocidad': 'mejorar_plan',
        '‚¨ÜÔ∏è mejorar plan': 'mejorar_plan',
        '‚¨Ü mejorar plan': 'mejorar_plan',
        'mejorar mi plan': 'mejorar_plan',
        'upgrade plan': 'mejorar_plan',

        'menu': 'menu',
        'men√∫': 'menu',
        'men√∫ principal': 'menu',
        'menu principal': 'menu',
        'inicio': 'menu',
        'volver': 'menu',
        'regresar': 'menu',
        'finalizar': 'finalizar',
        'terminar': 'finalizar',
        'salir': 'finalizar'
    };

    // 1. Verificar si es un ID directo
    if (menuPatterns[normalizedMessage]) {
        return menuPatterns[normalizedMessage];
    }

    // 2. Buscar por patrones que contengan texto espec√≠fico
    for (const [pattern, command] of Object.entries(menuPatterns)) {
        if (normalizedMessage.includes(pattern)) {
            return command;
        }
    }

    // 3. Verificar si contiene emojis y extraer texto principal
    const emojiPattern = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
    const textWithoutEmojis = normalizedMessage.replace(emojiPattern, '').trim();

    const titlePart = textWithoutEmojis.split('\n')[0].trim();

    for (const [pattern, command] of Object.entries(menuPatterns)) {
        if (titlePart.includes(pattern) || pattern.includes(titlePart)) {
            return command;
        }
    }

    return normalizedMessage;
}

// Simular el FlowManager
class ConversationFlowManager {
    constructor(messageService) {
        this.flows = [];
        this.messageService = messageService;
    }

    registerFlow(flow) {
        this.flows.push(flow);
        console.log(`‚úÖ Flujo registrado: ${flow.name}`);
    }

    async processMessage(user, message, session) {
        const msgText = typeof message === 'string' ? message : '';
        const command = extractMenuCommand(msgText);

        console.log(`üîç Procesando mensaje: "${msgText}"`);
        console.log(`üéØ Comando extra√≠do: "${command}"`);

        // Manejar comandos de navegaci√≥n global
        if (command === 'menu' || command === 'inicio') {
            this.resetSessionFlowState(session);
            await this.messageService.sendMainMenu(user.phoneNumber);
            return true;
        }

        if (command === 'finalizar') {
            this.resetSessionFlowState(session);
            await this.messageService.sendTextMessage(
                user.phoneNumber,
                '‚úÖ Gracias por usar nuestro servicio. ¬°Hasta pronto! Si necesitas ayuda, escribe "menu" para volver al men√∫ principal.'
            );
            return true;
        }

        // Verificar cada flujo en orden
        for (const flow of this.flows) {
            try {
                if (await flow.canHandle(user, message, session)) {
                    console.log(`‚úÖ Mensaje evaluado por flujo: ${flow.name}`);

                    const handled = await flow.handle(user, message, session);

                    if (handled) {
                        console.log(`üéâ Mensaje completamente manejado por flujo: ${flow.name}`);
                        return true;
                    }

                    console.log(`‚û°Ô∏è Flujo ${flow.name} configur√≥ estado pero deleg√≥ manejo a otros flujos`);
                }
            } catch (error) {
                console.error(`‚ùå Error en flujo ${flow.name}:`, error);
            }
        }

        console.log(`‚ùì Ning√∫n flujo pudo manejar el mensaje: "${msgText}"`);
        return false;
    }

    resetSessionFlowState(session) {
        session.creatingTicket = false;
        session.consultingInvoices = false;
        session.changingPassword = false;
        session.verifyingPayment = false;
        session.diagnosticInProgress = false;
        session.step = undefined;
        session.flowActive = '';
        session.ticketData = undefined;
        session.category = undefined;
        session.description = undefined;
        session.asunto = undefined;
        session.newPassword = undefined;
    }
}

// Simular flujos
class ClientMenuFlow {
    constructor() {
        this.name = 'ClientMenuFlow';
    }

    async canHandle(user, message, session) {
        const msgText = typeof message === 'string' ? message : '';
        const command = extractMenuCommand(msgText);

        const supportedCommands = ['ping', 'ticket', 'factura', 'mejorar_plan'];
        const canHandle = supportedCommands.includes(command);

        console.log(`  üîç ClientMenuFlow evaluando comando "${command}": ${canHandle ? 'S√ç' : 'NO'}`);
        return canHandle;
    }

    async handle(user, message, session) {
        const msgText = typeof message === 'string' ? message : '';
        const command = extractMenuCommand(msgText);

        console.log(`  ‚öôÔ∏è ClientMenuFlow procesando comando: ${command}`);

        switch (command) {
            case 'ping':
                session.diagnosticInProgress = true;
                console.log(`  üìã Configurando session.diagnosticInProgress = true`);
                return false; // Delegar a IPDiagnosticFlow

            case 'ticket':
                session.creatingTicket = true;
                console.log(`  üé´ Configurando session.creatingTicket = true`);
                return false; // Delegar a TicketCreationFlow

            case 'mejorar_plan':
                session.upgradingPlan = true;
                console.log(`  üìà Configurando session.upgradingPlan = true`);
                return false; // Delegar a PlanUpgradeFlow

            default:
                return false;
        }
    }
}

class IPDiagnosticFlow {
    constructor() {
        this.name = 'IPDiagnosticFlow';
    }

    async canHandle(user, message, session) {
        const canHandle = session.diagnosticInProgress === true;
        console.log(`  üîç IPDiagnosticFlow evaluando: diagnosticInProgress = ${session.diagnosticInProgress} ‚Üí ${canHandle ? 'S√ç' : 'NO'}`);
        return canHandle;
    }

    async handle(user, message, session) {
        console.log(`  üîß IPDiagnosticFlow manejando diagn√≥stico`);

        // Simular proceso de diagn√≥stico
        console.log(`  üì° Iniciando test de conexi√≥n para ${user.phoneNumber}...`);
        session.diagnosticInProgress = false;

        return true; // Mensaje completamente manejado
    }
}

class TicketCreationFlow {
    constructor() {
        this.name = 'TicketCreationFlow';
    }

    async canHandle(user, message, session) {
        const canHandle = session.creatingTicket === true;
        console.log(`  üîç TicketCreationFlow evaluando: creatingTicket = ${session.creatingTicket} ‚Üí ${canHandle ? 'S√ç' : 'NO'}`);
        return canHandle;
    }

    async handle(user, message, session) {
        console.log(`  üé´ TicketCreationFlow manejando creaci√≥n de ticket`);

        // Simular proceso de creaci√≥n de ticket
        console.log(`  üìù Iniciando creaci√≥n de ticket para ${user.phoneNumber}...`);
        session.creatingTicket = false;

        return true; // Mensaje completamente manejado
    }
}

class PlanUpgradeFlow {
    constructor() {
        this.name = 'PlanUpgradeFlow';
    }

    async canHandle(user, message, session) {
        const canHandle = session.upgradingPlan === true;
        console.log(`  üîç PlanUpgradeFlow evaluando: upgradingPlan = ${session.upgradingPlan} ‚Üí ${canHandle ? 'S√ç' : 'NO'}`);
        return canHandle;
    }

    async handle(user, message, session) {
        console.log(`  üìà PlanUpgradeFlow manejando upgrade de plan`);

        // Simular proceso de upgrade
        console.log(`  ‚¨ÜÔ∏è Iniciando proceso de mejora de plan para ${user.phoneNumber}...`);
        session.upgradingPlan = false;

        return true; // Mensaje completamente manejado
    }
}

// Configurar y probar
async function testFlowManager() {
    console.log('üöÄ INICIANDO PRUEBA DEL FLOWMANAGER CORREGIDO\n');

    const manager = new ConversationFlowManager(MockMessageService);

    // Registrar flujos en el orden correcto
    manager.registerFlow(new ClientMenuFlow());
    manager.registerFlow(new IPDiagnosticFlow());
    manager.registerFlow(new TicketCreationFlow());
    manager.registerFlow(new PlanUpgradeFlow());

    console.log('\n');

    // Casos de prueba
    const testCases = [
        {
            name: 'Test de Conexi√≥n',
            user: { phoneNumber: '+573001234567', isRegistered: true },
            message: 'üì° Test de Conexi√≥n',
            session: {}
        },
        {
            name: 'Soporte T√©cnico',
            user: { phoneNumber: '+573001234567', isRegistered: true },
            message: 'üîß Soporte T√©cnico',
            session: {}
        },
        {
            name: 'Mejorar Plan',
            user: { phoneNumber: '+573001234567', isRegistered: true },
            message: '‚¨ÜÔ∏è Mejorar Plan',
            session: {}
        },
        {
            name: 'Comando ping directo',
            user: { phoneNumber: '+573001234567', isRegistered: true },
            message: 'ping',
            session: {}
        },
        {
            name: 'Mensaje no reconocido',
            user: { phoneNumber: '+573001234567', isRegistered: true },
            message: 'mensaje aleatorio que no deber√≠a ser reconocido',
            session: {}
        }
    ];

    for (const testCase of testCases) {
        console.log(`\n${'='.repeat(60)}`);
        console.log(`üß™ PROBANDO: ${testCase.name}`);
        console.log(`üì§ Mensaje: "${testCase.message}"`);
        console.log(`${'='.repeat(60)}`);

        const sessionCopy = { ...testCase.session };

        try {
            const result = await manager.processMessage(testCase.user, testCase.message, sessionCopy);

            console.log(`\nüìä RESULTADO: ${result ? '‚úÖ MANEJADO' : '‚ùå NO MANEJADO'}`);
            console.log(`üìã Estado de sesi√≥n final:`, sessionCopy);

            if (!result) {
                console.log(`‚ùó PROBLEMA: El mensaje "${testCase.message}" NO fue manejado por ning√∫n flujo`);
            }
        } catch (error) {
            console.error(`‚ùå ERROR durante la prueba:`, error);
        }
    }

    console.log(`\n${'='.repeat(60)}`);
    console.log('üèÅ PRUEBAS COMPLETADAS');
    console.log(`${'='.repeat(60)}\n`);
}

// Ejecutar las pruebas
testFlowManager().catch(console.error);
